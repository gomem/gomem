// Code generated by pkg/dataframe/element_numeric.gen.go.tmpl. DO NOT EDIT.

// Copyright 2019 Nick Poorman
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dataframe

import (
	"errors"
	"fmt"

	"github.com/apache/arrow/go/arrow"
	"github.com/apache/arrow/go/arrow/decimal128"
	"github.com/apache/arrow/go/arrow/float16"
)

// BooleanElement has logic to apply to this type.
type BooleanElement struct {
	v interface{}
}

// NewBooleanElement creates a new BooleanElement logic wrapper
// from the given value provided as v.
func NewBooleanElement(v interface{}) *BooleanElement {
	return &BooleanElement{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e BooleanElement) compare(r Element, f func(left, right bool) bool) (bool, error) {
	rE, ok := r.(*BooleanElement)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to BooleanElement", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(bool)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a bool", e.v)
	}
	rv, rok := rE.v.(bool)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a bool", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left BooleanElement is equal to the right BooleanElement.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e BooleanElement) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right bool) bool {
		return left == right
	})
}

// EqStrict returns true if the left BooleanElement is equal to the right BooleanElement.
// When both are nil EqStrict returns true.
func (e BooleanElement) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right bool) bool {
		return left == right
	})
}

// Neq returns true if the left BooleanElement
// is not equal to the right BooleanElement.
func (e BooleanElement) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left BooleanElement
// is less than the right BooleanElement.
func (e BooleanElement) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Boolean")
}

// LessEq returns true if the left BooleanElement
// is less than or equal to the right BooleanElement.
func (e BooleanElement) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Boolean")
}

// Greater returns true if the left BooleanElement
// is greter than the right BooleanElement.
func (e BooleanElement) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Boolean")
}

// GreaterEq returns true if the left BooleanElement
// is greter than or equal to the right BooleanElement.
func (e BooleanElement) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Boolean")
}

// Accessor/conversion methods

// Copy returns a copy of this BooleanElement.
func (e BooleanElement) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e BooleanElement) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e BooleanElement) IsNil() bool {
	return e.v == nil
}

// Date32Element has logic to apply to this type.
type Date32Element struct {
	v interface{}
}

// NewDate32Element creates a new Date32Element logic wrapper
// from the given value provided as v.
func NewDate32Element(v interface{}) *Date32Element {
	return &Date32Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Date32Element) compare(r Element, f func(left, right arrow.Date32) bool) (bool, error) {
	rE, ok := r.(*Date32Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Date32Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(arrow.Date32)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Date32", e.v)
	}
	rv, rok := rE.v.(arrow.Date32)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Date32", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Date32Element is equal to the right Date32Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Date32Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right arrow.Date32) bool {
		return left == right
	})
}

// EqStrict returns true if the left Date32Element is equal to the right Date32Element.
// When both are nil EqStrict returns true.
func (e Date32Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right arrow.Date32) bool {
		return left == right
	})
}

// Neq returns true if the left Date32Element
// is not equal to the right Date32Element.
func (e Date32Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Date32Element
// is less than the right Date32Element.
func (e Date32Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Date32")
}

// LessEq returns true if the left Date32Element
// is less than or equal to the right Date32Element.
func (e Date32Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Date32")
}

// Greater returns true if the left Date32Element
// is greter than the right Date32Element.
func (e Date32Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Date32")
}

// GreaterEq returns true if the left Date32Element
// is greter than or equal to the right Date32Element.
func (e Date32Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Date32")
}

// Accessor/conversion methods

// Copy returns a copy of this Date32Element.
func (e Date32Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Date32Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Date32Element) IsNil() bool {
	return e.v == nil
}

// Date64Element has logic to apply to this type.
type Date64Element struct {
	v interface{}
}

// NewDate64Element creates a new Date64Element logic wrapper
// from the given value provided as v.
func NewDate64Element(v interface{}) *Date64Element {
	return &Date64Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Date64Element) compare(r Element, f func(left, right arrow.Date64) bool) (bool, error) {
	rE, ok := r.(*Date64Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Date64Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(arrow.Date64)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Date64", e.v)
	}
	rv, rok := rE.v.(arrow.Date64)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Date64", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Date64Element is equal to the right Date64Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Date64Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right arrow.Date64) bool {
		return left == right
	})
}

// EqStrict returns true if the left Date64Element is equal to the right Date64Element.
// When both are nil EqStrict returns true.
func (e Date64Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right arrow.Date64) bool {
		return left == right
	})
}

// Neq returns true if the left Date64Element
// is not equal to the right Date64Element.
func (e Date64Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Date64Element
// is less than the right Date64Element.
func (e Date64Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Date64")
}

// LessEq returns true if the left Date64Element
// is less than or equal to the right Date64Element.
func (e Date64Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Date64")
}

// Greater returns true if the left Date64Element
// is greter than the right Date64Element.
func (e Date64Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Date64")
}

// GreaterEq returns true if the left Date64Element
// is greter than or equal to the right Date64Element.
func (e Date64Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Date64")
}

// Accessor/conversion methods

// Copy returns a copy of this Date64Element.
func (e Date64Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Date64Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Date64Element) IsNil() bool {
	return e.v == nil
}

// DayTimeIntervalElement has logic to apply to this type.
type DayTimeIntervalElement struct {
	v interface{}
}

// NewDayTimeIntervalElement creates a new DayTimeIntervalElement logic wrapper
// from the given value provided as v.
func NewDayTimeIntervalElement(v interface{}) *DayTimeIntervalElement {
	return &DayTimeIntervalElement{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e DayTimeIntervalElement) compare(r Element, f func(left, right arrow.DayTimeInterval) bool) (bool, error) {
	rE, ok := r.(*DayTimeIntervalElement)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to DayTimeIntervalElement", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(arrow.DayTimeInterval)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a arrow.DayTimeInterval", e.v)
	}
	rv, rok := rE.v.(arrow.DayTimeInterval)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a arrow.DayTimeInterval", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left DayTimeIntervalElement is equal to the right DayTimeIntervalElement.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e DayTimeIntervalElement) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right arrow.DayTimeInterval) bool {
		return left.Days == right.Days && left.Milliseconds == right.Milliseconds
	})
}

// EqStrict returns true if the left DayTimeIntervalElement is equal to the right DayTimeIntervalElement.
// When both are nil EqStrict returns true.
func (e DayTimeIntervalElement) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right arrow.DayTimeInterval) bool {
		return left.Days == right.Days && left.Milliseconds == right.Milliseconds
	})
}

// Neq returns true if the left DayTimeIntervalElement
// is not equal to the right DayTimeIntervalElement.
func (e DayTimeIntervalElement) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left DayTimeIntervalElement
// is less than the right DayTimeIntervalElement.
func (e DayTimeIntervalElement) Less(r Element) (bool, error) {
	return e.compare(r, func(left, right arrow.DayTimeInterval) bool {
		return left.Days < right.Days && left.Milliseconds < right.Milliseconds
	})
}

// LessEq returns true if the left DayTimeIntervalElement
// is less than or equal to the right DayTimeIntervalElement.
func (e DayTimeIntervalElement) LessEq(r Element) (bool, error) {
	return e.compare(r, func(left, right arrow.DayTimeInterval) bool {
		return left.Days <= right.Days && left.Milliseconds <= right.Milliseconds
	})
}

// Greater returns true if the left DayTimeIntervalElement
// is greter than the right DayTimeIntervalElement.
func (e DayTimeIntervalElement) Greater(r Element) (bool, error) {
	return e.compare(r, func(left, right arrow.DayTimeInterval) bool {
		return left.Days > right.Days && left.Milliseconds > right.Milliseconds
	})
}

// GreaterEq returns true if the left DayTimeIntervalElement
// is greter than or equal to the right DayTimeIntervalElement.
func (e DayTimeIntervalElement) GreaterEq(r Element) (bool, error) {
	return e.compare(r, func(left, right arrow.DayTimeInterval) bool {
		return left.Days >= right.Days && left.Milliseconds >= right.Milliseconds
	})
}

// Accessor/conversion methods

// Copy returns a copy of this DayTimeIntervalElement.
func (e DayTimeIntervalElement) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e DayTimeIntervalElement) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e DayTimeIntervalElement) IsNil() bool {
	return e.v == nil
}

// Decimal128Element has logic to apply to this type.
type Decimal128Element struct {
	v interface{}
}

// NewDecimal128Element creates a new Decimal128Element logic wrapper
// from the given value provided as v.
func NewDecimal128Element(v interface{}) *Decimal128Element {
	return &Decimal128Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Decimal128Element) compare(r Element, f func(left, right decimal128.Num) bool) (bool, error) {
	rE, ok := r.(*Decimal128Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Decimal128Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(decimal128.Num)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a decimal128.Num", e.v)
	}
	rv, rok := rE.v.(decimal128.Num)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a decimal128.Num", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Decimal128Element is equal to the right Decimal128Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Decimal128Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right decimal128.Num) bool {
		return left.HighBits() == right.HighBits() && left.LowBits() == right.LowBits()
	})
}

// EqStrict returns true if the left Decimal128Element is equal to the right Decimal128Element.
// When both are nil EqStrict returns true.
func (e Decimal128Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right decimal128.Num) bool {
		return left.HighBits() == right.HighBits() && left.LowBits() == right.LowBits()
	})
}

// Neq returns true if the left Decimal128Element
// is not equal to the right Decimal128Element.
func (e Decimal128Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Decimal128Element
// is less than the right Decimal128Element.
func (e Decimal128Element) Less(r Element) (bool, error) {
	return e.compare(r, func(left, right decimal128.Num) bool {
		return left.HighBits() < right.HighBits() || (left.HighBits() == right.HighBits() && left.LowBits() < right.LowBits())
	})
}

// LessEq returns true if the left Decimal128Element
// is less than or equal to the right Decimal128Element.
func (e Decimal128Element) LessEq(r Element) (bool, error) {
	return e.compare(r, func(left, right decimal128.Num) bool {
		return !(right.HighBits() < left.HighBits() || (right.HighBits() == left.HighBits() && right.LowBits() < left.LowBits()))
	})
}

// Greater returns true if the left Decimal128Element
// is greter than the right Decimal128Element.
func (e Decimal128Element) Greater(r Element) (bool, error) {
	return e.compare(r, func(left, right decimal128.Num) bool {
		return right.HighBits() < left.HighBits() || (right.HighBits() == left.HighBits() && right.LowBits() < left.LowBits())
	})
}

// GreaterEq returns true if the left Decimal128Element
// is greter than or equal to the right Decimal128Element.
func (e Decimal128Element) GreaterEq(r Element) (bool, error) {
	return e.compare(r, func(left, right decimal128.Num) bool {
		return !(left.HighBits() < right.HighBits() || (left.HighBits() == right.HighBits() && left.LowBits() < right.LowBits()))
	})
}

// Accessor/conversion methods

// Copy returns a copy of this Decimal128Element.
func (e Decimal128Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Decimal128Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Decimal128Element) IsNil() bool {
	return e.v == nil
}

// DurationElement has logic to apply to this type.
type DurationElement struct {
	v interface{}
}

// NewDurationElement creates a new DurationElement logic wrapper
// from the given value provided as v.
func NewDurationElement(v interface{}) *DurationElement {
	return &DurationElement{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e DurationElement) compare(r Element, f func(left, right arrow.Duration) bool) (bool, error) {
	rE, ok := r.(*DurationElement)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to DurationElement", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(arrow.Duration)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Duration", e.v)
	}
	rv, rok := rE.v.(arrow.Duration)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Duration", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left DurationElement is equal to the right DurationElement.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e DurationElement) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right arrow.Duration) bool {
		return left == right
	})
}

// EqStrict returns true if the left DurationElement is equal to the right DurationElement.
// When both are nil EqStrict returns true.
func (e DurationElement) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right arrow.Duration) bool {
		return left == right
	})
}

// Neq returns true if the left DurationElement
// is not equal to the right DurationElement.
func (e DurationElement) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left DurationElement
// is less than the right DurationElement.
func (e DurationElement) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Duration")
}

// LessEq returns true if the left DurationElement
// is less than or equal to the right DurationElement.
func (e DurationElement) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Duration")
}

// Greater returns true if the left DurationElement
// is greter than the right DurationElement.
func (e DurationElement) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Duration")
}

// GreaterEq returns true if the left DurationElement
// is greter than or equal to the right DurationElement.
func (e DurationElement) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Duration")
}

// Accessor/conversion methods

// Copy returns a copy of this DurationElement.
func (e DurationElement) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e DurationElement) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e DurationElement) IsNil() bool {
	return e.v == nil
}

// Float16Element has logic to apply to this type.
type Float16Element struct {
	v interface{}
}

// NewFloat16Element creates a new Float16Element logic wrapper
// from the given value provided as v.
func NewFloat16Element(v interface{}) *Float16Element {
	return &Float16Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Float16Element) compare(r Element, f func(left, right float16.Num) bool) (bool, error) {
	rE, ok := r.(*Float16Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Float16Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(float16.Num)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a float16.Num", e.v)
	}
	rv, rok := rE.v.(float16.Num)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a float16.Num", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Float16Element is equal to the right Float16Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Float16Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right float16.Num) bool {
		return left.Uint16() == right.Uint16()
	})
}

// EqStrict returns true if the left Float16Element is equal to the right Float16Element.
// When both are nil EqStrict returns true.
func (e Float16Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right float16.Num) bool {
		return left.Uint16() == right.Uint16()
	})
}

// Neq returns true if the left Float16Element
// is not equal to the right Float16Element.
func (e Float16Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Float16Element
// is less than the right Float16Element.
func (e Float16Element) Less(r Element) (bool, error) {
	return e.compare(r, func(left, right float16.Num) bool {
		return left.Uint16() < right.Uint16()
	})
}

// LessEq returns true if the left Float16Element
// is less than or equal to the right Float16Element.
func (e Float16Element) LessEq(r Element) (bool, error) {
	return e.compare(r, func(left, right float16.Num) bool {
		return left.Uint16() <= right.Uint16()
	})
}

// Greater returns true if the left Float16Element
// is greter than the right Float16Element.
func (e Float16Element) Greater(r Element) (bool, error) {
	return e.compare(r, func(left, right float16.Num) bool {
		return left.Uint16() > right.Uint16()
	})
}

// GreaterEq returns true if the left Float16Element
// is greter than or equal to the right Float16Element.
func (e Float16Element) GreaterEq(r Element) (bool, error) {
	return e.compare(r, func(left, right float16.Num) bool {
		return left.Uint16() >= right.Uint16()
	})
}

// Accessor/conversion methods

// Copy returns a copy of this Float16Element.
func (e Float16Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Float16Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Float16Element) IsNil() bool {
	return e.v == nil
}

// Float32Element has logic to apply to this type.
type Float32Element struct {
	v interface{}
}

// NewFloat32Element creates a new Float32Element logic wrapper
// from the given value provided as v.
func NewFloat32Element(v interface{}) *Float32Element {
	return &Float32Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Float32Element) compare(r Element, f func(left, right float32) bool) (bool, error) {
	rE, ok := r.(*Float32Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Float32Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(float32)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a float32", e.v)
	}
	rv, rok := rE.v.(float32)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a float32", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Float32Element is equal to the right Float32Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Float32Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right float32) bool {
		return left == right
	})
}

// EqStrict returns true if the left Float32Element is equal to the right Float32Element.
// When both are nil EqStrict returns true.
func (e Float32Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right float32) bool {
		return left == right
	})
}

// Neq returns true if the left Float32Element
// is not equal to the right Float32Element.
func (e Float32Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Float32Element
// is less than the right Float32Element.
func (e Float32Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Float32")
}

// LessEq returns true if the left Float32Element
// is less than or equal to the right Float32Element.
func (e Float32Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Float32")
}

// Greater returns true if the left Float32Element
// is greter than the right Float32Element.
func (e Float32Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Float32")
}

// GreaterEq returns true if the left Float32Element
// is greter than or equal to the right Float32Element.
func (e Float32Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Float32")
}

// Accessor/conversion methods

// Copy returns a copy of this Float32Element.
func (e Float32Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Float32Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Float32Element) IsNil() bool {
	return e.v == nil
}

// Float64Element has logic to apply to this type.
type Float64Element struct {
	v interface{}
}

// NewFloat64Element creates a new Float64Element logic wrapper
// from the given value provided as v.
func NewFloat64Element(v interface{}) *Float64Element {
	return &Float64Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Float64Element) compare(r Element, f func(left, right float64) bool) (bool, error) {
	rE, ok := r.(*Float64Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Float64Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(float64)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a float64", e.v)
	}
	rv, rok := rE.v.(float64)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a float64", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Float64Element is equal to the right Float64Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Float64Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right float64) bool {
		return left == right
	})
}

// EqStrict returns true if the left Float64Element is equal to the right Float64Element.
// When both are nil EqStrict returns true.
func (e Float64Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right float64) bool {
		return left == right
	})
}

// Neq returns true if the left Float64Element
// is not equal to the right Float64Element.
func (e Float64Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Float64Element
// is less than the right Float64Element.
func (e Float64Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Float64")
}

// LessEq returns true if the left Float64Element
// is less than or equal to the right Float64Element.
func (e Float64Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Float64")
}

// Greater returns true if the left Float64Element
// is greter than the right Float64Element.
func (e Float64Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Float64")
}

// GreaterEq returns true if the left Float64Element
// is greter than or equal to the right Float64Element.
func (e Float64Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Float64")
}

// Accessor/conversion methods

// Copy returns a copy of this Float64Element.
func (e Float64Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Float64Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Float64Element) IsNil() bool {
	return e.v == nil
}

// Int16Element has logic to apply to this type.
type Int16Element struct {
	v interface{}
}

// NewInt16Element creates a new Int16Element logic wrapper
// from the given value provided as v.
func NewInt16Element(v interface{}) *Int16Element {
	return &Int16Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Int16Element) compare(r Element, f func(left, right int16) bool) (bool, error) {
	rE, ok := r.(*Int16Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Int16Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(int16)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a int16", e.v)
	}
	rv, rok := rE.v.(int16)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a int16", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Int16Element is equal to the right Int16Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Int16Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right int16) bool {
		return left == right
	})
}

// EqStrict returns true if the left Int16Element is equal to the right Int16Element.
// When both are nil EqStrict returns true.
func (e Int16Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right int16) bool {
		return left == right
	})
}

// Neq returns true if the left Int16Element
// is not equal to the right Int16Element.
func (e Int16Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Int16Element
// is less than the right Int16Element.
func (e Int16Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Int16")
}

// LessEq returns true if the left Int16Element
// is less than or equal to the right Int16Element.
func (e Int16Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Int16")
}

// Greater returns true if the left Int16Element
// is greter than the right Int16Element.
func (e Int16Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Int16")
}

// GreaterEq returns true if the left Int16Element
// is greter than or equal to the right Int16Element.
func (e Int16Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Int16")
}

// Accessor/conversion methods

// Copy returns a copy of this Int16Element.
func (e Int16Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Int16Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Int16Element) IsNil() bool {
	return e.v == nil
}

// Int32Element has logic to apply to this type.
type Int32Element struct {
	v interface{}
}

// NewInt32Element creates a new Int32Element logic wrapper
// from the given value provided as v.
func NewInt32Element(v interface{}) *Int32Element {
	return &Int32Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Int32Element) compare(r Element, f func(left, right int32) bool) (bool, error) {
	rE, ok := r.(*Int32Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Int32Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(int32)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a int32", e.v)
	}
	rv, rok := rE.v.(int32)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a int32", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Int32Element is equal to the right Int32Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Int32Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right int32) bool {
		return left == right
	})
}

// EqStrict returns true if the left Int32Element is equal to the right Int32Element.
// When both are nil EqStrict returns true.
func (e Int32Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right int32) bool {
		return left == right
	})
}

// Neq returns true if the left Int32Element
// is not equal to the right Int32Element.
func (e Int32Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Int32Element
// is less than the right Int32Element.
func (e Int32Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Int32")
}

// LessEq returns true if the left Int32Element
// is less than or equal to the right Int32Element.
func (e Int32Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Int32")
}

// Greater returns true if the left Int32Element
// is greter than the right Int32Element.
func (e Int32Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Int32")
}

// GreaterEq returns true if the left Int32Element
// is greter than or equal to the right Int32Element.
func (e Int32Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Int32")
}

// Accessor/conversion methods

// Copy returns a copy of this Int32Element.
func (e Int32Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Int32Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Int32Element) IsNil() bool {
	return e.v == nil
}

// Int64Element has logic to apply to this type.
type Int64Element struct {
	v interface{}
}

// NewInt64Element creates a new Int64Element logic wrapper
// from the given value provided as v.
func NewInt64Element(v interface{}) *Int64Element {
	return &Int64Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Int64Element) compare(r Element, f func(left, right int64) bool) (bool, error) {
	rE, ok := r.(*Int64Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Int64Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(int64)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a int64", e.v)
	}
	rv, rok := rE.v.(int64)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a int64", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Int64Element is equal to the right Int64Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Int64Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right int64) bool {
		return left == right
	})
}

// EqStrict returns true if the left Int64Element is equal to the right Int64Element.
// When both are nil EqStrict returns true.
func (e Int64Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right int64) bool {
		return left == right
	})
}

// Neq returns true if the left Int64Element
// is not equal to the right Int64Element.
func (e Int64Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Int64Element
// is less than the right Int64Element.
func (e Int64Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Int64")
}

// LessEq returns true if the left Int64Element
// is less than or equal to the right Int64Element.
func (e Int64Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Int64")
}

// Greater returns true if the left Int64Element
// is greter than the right Int64Element.
func (e Int64Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Int64")
}

// GreaterEq returns true if the left Int64Element
// is greter than or equal to the right Int64Element.
func (e Int64Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Int64")
}

// Accessor/conversion methods

// Copy returns a copy of this Int64Element.
func (e Int64Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Int64Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Int64Element) IsNil() bool {
	return e.v == nil
}

// Int8Element has logic to apply to this type.
type Int8Element struct {
	v interface{}
}

// NewInt8Element creates a new Int8Element logic wrapper
// from the given value provided as v.
func NewInt8Element(v interface{}) *Int8Element {
	return &Int8Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Int8Element) compare(r Element, f func(left, right int8) bool) (bool, error) {
	rE, ok := r.(*Int8Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Int8Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(int8)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a int8", e.v)
	}
	rv, rok := rE.v.(int8)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a int8", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Int8Element is equal to the right Int8Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Int8Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right int8) bool {
		return left == right
	})
}

// EqStrict returns true if the left Int8Element is equal to the right Int8Element.
// When both are nil EqStrict returns true.
func (e Int8Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right int8) bool {
		return left == right
	})
}

// Neq returns true if the left Int8Element
// is not equal to the right Int8Element.
func (e Int8Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Int8Element
// is less than the right Int8Element.
func (e Int8Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Int8")
}

// LessEq returns true if the left Int8Element
// is less than or equal to the right Int8Element.
func (e Int8Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Int8")
}

// Greater returns true if the left Int8Element
// is greter than the right Int8Element.
func (e Int8Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Int8")
}

// GreaterEq returns true if the left Int8Element
// is greter than or equal to the right Int8Element.
func (e Int8Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Int8")
}

// Accessor/conversion methods

// Copy returns a copy of this Int8Element.
func (e Int8Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Int8Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Int8Element) IsNil() bool {
	return e.v == nil
}

// MonthIntervalElement has logic to apply to this type.
type MonthIntervalElement struct {
	v interface{}
}

// NewMonthIntervalElement creates a new MonthIntervalElement logic wrapper
// from the given value provided as v.
func NewMonthIntervalElement(v interface{}) *MonthIntervalElement {
	return &MonthIntervalElement{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e MonthIntervalElement) compare(r Element, f func(left, right arrow.MonthInterval) bool) (bool, error) {
	rE, ok := r.(*MonthIntervalElement)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to MonthIntervalElement", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(arrow.MonthInterval)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a arrow.MonthInterval", e.v)
	}
	rv, rok := rE.v.(arrow.MonthInterval)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a arrow.MonthInterval", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left MonthIntervalElement is equal to the right MonthIntervalElement.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e MonthIntervalElement) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right arrow.MonthInterval) bool {
		return left == right
	})
}

// EqStrict returns true if the left MonthIntervalElement is equal to the right MonthIntervalElement.
// When both are nil EqStrict returns true.
func (e MonthIntervalElement) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right arrow.MonthInterval) bool {
		return left == right
	})
}

// Neq returns true if the left MonthIntervalElement
// is not equal to the right MonthIntervalElement.
func (e MonthIntervalElement) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left MonthIntervalElement
// is less than the right MonthIntervalElement.
func (e MonthIntervalElement) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on MonthInterval")
}

// LessEq returns true if the left MonthIntervalElement
// is less than or equal to the right MonthIntervalElement.
func (e MonthIntervalElement) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on MonthInterval")
}

// Greater returns true if the left MonthIntervalElement
// is greter than the right MonthIntervalElement.
func (e MonthIntervalElement) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on MonthInterval")
}

// GreaterEq returns true if the left MonthIntervalElement
// is greter than or equal to the right MonthIntervalElement.
func (e MonthIntervalElement) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on MonthInterval")
}

// Accessor/conversion methods

// Copy returns a copy of this MonthIntervalElement.
func (e MonthIntervalElement) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e MonthIntervalElement) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e MonthIntervalElement) IsNil() bool {
	return e.v == nil
}

// StringElement has logic to apply to this type.
type StringElement struct {
	v interface{}
}

// NewStringElement creates a new StringElement logic wrapper
// from the given value provided as v.
func NewStringElement(v interface{}) *StringElement {
	return &StringElement{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e StringElement) compare(r Element, f func(left, right string) bool) (bool, error) {
	rE, ok := r.(*StringElement)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to StringElement", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(string)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a string", e.v)
	}
	rv, rok := rE.v.(string)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a string", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left StringElement is equal to the right StringElement.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e StringElement) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right string) bool {
		return left == right
	})
}

// EqStrict returns true if the left StringElement is equal to the right StringElement.
// When both are nil EqStrict returns true.
func (e StringElement) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right string) bool {
		return left == right
	})
}

// Neq returns true if the left StringElement
// is not equal to the right StringElement.
func (e StringElement) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left StringElement
// is less than the right StringElement.
func (e StringElement) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on String")
}

// LessEq returns true if the left StringElement
// is less than or equal to the right StringElement.
func (e StringElement) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on String")
}

// Greater returns true if the left StringElement
// is greter than the right StringElement.
func (e StringElement) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on String")
}

// GreaterEq returns true if the left StringElement
// is greter than or equal to the right StringElement.
func (e StringElement) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on String")
}

// Accessor/conversion methods

// Copy returns a copy of this StringElement.
func (e StringElement) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e StringElement) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e StringElement) IsNil() bool {
	return e.v == nil
}

// Time32Element has logic to apply to this type.
type Time32Element struct {
	v interface{}
}

// NewTime32Element creates a new Time32Element logic wrapper
// from the given value provided as v.
func NewTime32Element(v interface{}) *Time32Element {
	return &Time32Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Time32Element) compare(r Element, f func(left, right arrow.Time32) bool) (bool, error) {
	rE, ok := r.(*Time32Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Time32Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(arrow.Time32)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Time32", e.v)
	}
	rv, rok := rE.v.(arrow.Time32)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Time32", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Time32Element is equal to the right Time32Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Time32Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right arrow.Time32) bool {
		return left == right
	})
}

// EqStrict returns true if the left Time32Element is equal to the right Time32Element.
// When both are nil EqStrict returns true.
func (e Time32Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right arrow.Time32) bool {
		return left == right
	})
}

// Neq returns true if the left Time32Element
// is not equal to the right Time32Element.
func (e Time32Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Time32Element
// is less than the right Time32Element.
func (e Time32Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Time32")
}

// LessEq returns true if the left Time32Element
// is less than or equal to the right Time32Element.
func (e Time32Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Time32")
}

// Greater returns true if the left Time32Element
// is greter than the right Time32Element.
func (e Time32Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Time32")
}

// GreaterEq returns true if the left Time32Element
// is greter than or equal to the right Time32Element.
func (e Time32Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Time32")
}

// Accessor/conversion methods

// Copy returns a copy of this Time32Element.
func (e Time32Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Time32Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Time32Element) IsNil() bool {
	return e.v == nil
}

// Time64Element has logic to apply to this type.
type Time64Element struct {
	v interface{}
}

// NewTime64Element creates a new Time64Element logic wrapper
// from the given value provided as v.
func NewTime64Element(v interface{}) *Time64Element {
	return &Time64Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Time64Element) compare(r Element, f func(left, right arrow.Time64) bool) (bool, error) {
	rE, ok := r.(*Time64Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Time64Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(arrow.Time64)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Time64", e.v)
	}
	rv, rok := rE.v.(arrow.Time64)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Time64", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Time64Element is equal to the right Time64Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Time64Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right arrow.Time64) bool {
		return left == right
	})
}

// EqStrict returns true if the left Time64Element is equal to the right Time64Element.
// When both are nil EqStrict returns true.
func (e Time64Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right arrow.Time64) bool {
		return left == right
	})
}

// Neq returns true if the left Time64Element
// is not equal to the right Time64Element.
func (e Time64Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Time64Element
// is less than the right Time64Element.
func (e Time64Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Time64")
}

// LessEq returns true if the left Time64Element
// is less than or equal to the right Time64Element.
func (e Time64Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Time64")
}

// Greater returns true if the left Time64Element
// is greter than the right Time64Element.
func (e Time64Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Time64")
}

// GreaterEq returns true if the left Time64Element
// is greter than or equal to the right Time64Element.
func (e Time64Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Time64")
}

// Accessor/conversion methods

// Copy returns a copy of this Time64Element.
func (e Time64Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Time64Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Time64Element) IsNil() bool {
	return e.v == nil
}

// TimestampElement has logic to apply to this type.
type TimestampElement struct {
	v interface{}
}

// NewTimestampElement creates a new TimestampElement logic wrapper
// from the given value provided as v.
func NewTimestampElement(v interface{}) *TimestampElement {
	return &TimestampElement{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e TimestampElement) compare(r Element, f func(left, right arrow.Timestamp) bool) (bool, error) {
	rE, ok := r.(*TimestampElement)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to TimestampElement", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(arrow.Timestamp)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Timestamp", e.v)
	}
	rv, rok := rE.v.(arrow.Timestamp)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a arrow.Timestamp", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left TimestampElement is equal to the right TimestampElement.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e TimestampElement) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right arrow.Timestamp) bool {
		return left == right
	})
}

// EqStrict returns true if the left TimestampElement is equal to the right TimestampElement.
// When both are nil EqStrict returns true.
func (e TimestampElement) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right arrow.Timestamp) bool {
		return left == right
	})
}

// Neq returns true if the left TimestampElement
// is not equal to the right TimestampElement.
func (e TimestampElement) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left TimestampElement
// is less than the right TimestampElement.
func (e TimestampElement) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Timestamp")
}

// LessEq returns true if the left TimestampElement
// is less than or equal to the right TimestampElement.
func (e TimestampElement) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Timestamp")
}

// Greater returns true if the left TimestampElement
// is greter than the right TimestampElement.
func (e TimestampElement) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Timestamp")
}

// GreaterEq returns true if the left TimestampElement
// is greter than or equal to the right TimestampElement.
func (e TimestampElement) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Timestamp")
}

// Accessor/conversion methods

// Copy returns a copy of this TimestampElement.
func (e TimestampElement) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e TimestampElement) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e TimestampElement) IsNil() bool {
	return e.v == nil
}

// Uint16Element has logic to apply to this type.
type Uint16Element struct {
	v interface{}
}

// NewUint16Element creates a new Uint16Element logic wrapper
// from the given value provided as v.
func NewUint16Element(v interface{}) *Uint16Element {
	return &Uint16Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Uint16Element) compare(r Element, f func(left, right uint16) bool) (bool, error) {
	rE, ok := r.(*Uint16Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Uint16Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(uint16)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a uint16", e.v)
	}
	rv, rok := rE.v.(uint16)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a uint16", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Uint16Element is equal to the right Uint16Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Uint16Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right uint16) bool {
		return left == right
	})
}

// EqStrict returns true if the left Uint16Element is equal to the right Uint16Element.
// When both are nil EqStrict returns true.
func (e Uint16Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right uint16) bool {
		return left == right
	})
}

// Neq returns true if the left Uint16Element
// is not equal to the right Uint16Element.
func (e Uint16Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Uint16Element
// is less than the right Uint16Element.
func (e Uint16Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Uint16")
}

// LessEq returns true if the left Uint16Element
// is less than or equal to the right Uint16Element.
func (e Uint16Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Uint16")
}

// Greater returns true if the left Uint16Element
// is greter than the right Uint16Element.
func (e Uint16Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Uint16")
}

// GreaterEq returns true if the left Uint16Element
// is greter than or equal to the right Uint16Element.
func (e Uint16Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Uint16")
}

// Accessor/conversion methods

// Copy returns a copy of this Uint16Element.
func (e Uint16Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Uint16Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Uint16Element) IsNil() bool {
	return e.v == nil
}

// Uint32Element has logic to apply to this type.
type Uint32Element struct {
	v interface{}
}

// NewUint32Element creates a new Uint32Element logic wrapper
// from the given value provided as v.
func NewUint32Element(v interface{}) *Uint32Element {
	return &Uint32Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Uint32Element) compare(r Element, f func(left, right uint32) bool) (bool, error) {
	rE, ok := r.(*Uint32Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Uint32Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(uint32)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a uint32", e.v)
	}
	rv, rok := rE.v.(uint32)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a uint32", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Uint32Element is equal to the right Uint32Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Uint32Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right uint32) bool {
		return left == right
	})
}

// EqStrict returns true if the left Uint32Element is equal to the right Uint32Element.
// When both are nil EqStrict returns true.
func (e Uint32Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right uint32) bool {
		return left == right
	})
}

// Neq returns true if the left Uint32Element
// is not equal to the right Uint32Element.
func (e Uint32Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Uint32Element
// is less than the right Uint32Element.
func (e Uint32Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Uint32")
}

// LessEq returns true if the left Uint32Element
// is less than or equal to the right Uint32Element.
func (e Uint32Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Uint32")
}

// Greater returns true if the left Uint32Element
// is greter than the right Uint32Element.
func (e Uint32Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Uint32")
}

// GreaterEq returns true if the left Uint32Element
// is greter than or equal to the right Uint32Element.
func (e Uint32Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Uint32")
}

// Accessor/conversion methods

// Copy returns a copy of this Uint32Element.
func (e Uint32Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Uint32Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Uint32Element) IsNil() bool {
	return e.v == nil
}

// Uint64Element has logic to apply to this type.
type Uint64Element struct {
	v interface{}
}

// NewUint64Element creates a new Uint64Element logic wrapper
// from the given value provided as v.
func NewUint64Element(v interface{}) *Uint64Element {
	return &Uint64Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Uint64Element) compare(r Element, f func(left, right uint64) bool) (bool, error) {
	rE, ok := r.(*Uint64Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Uint64Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(uint64)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a uint64", e.v)
	}
	rv, rok := rE.v.(uint64)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a uint64", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Uint64Element is equal to the right Uint64Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Uint64Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right uint64) bool {
		return left == right
	})
}

// EqStrict returns true if the left Uint64Element is equal to the right Uint64Element.
// When both are nil EqStrict returns true.
func (e Uint64Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right uint64) bool {
		return left == right
	})
}

// Neq returns true if the left Uint64Element
// is not equal to the right Uint64Element.
func (e Uint64Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Uint64Element
// is less than the right Uint64Element.
func (e Uint64Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Uint64")
}

// LessEq returns true if the left Uint64Element
// is less than or equal to the right Uint64Element.
func (e Uint64Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Uint64")
}

// Greater returns true if the left Uint64Element
// is greter than the right Uint64Element.
func (e Uint64Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Uint64")
}

// GreaterEq returns true if the left Uint64Element
// is greter than or equal to the right Uint64Element.
func (e Uint64Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Uint64")
}

// Accessor/conversion methods

// Copy returns a copy of this Uint64Element.
func (e Uint64Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Uint64Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Uint64Element) IsNil() bool {
	return e.v == nil
}

// Uint8Element has logic to apply to this type.
type Uint8Element struct {
	v interface{}
}

// NewUint8Element creates a new Uint8Element logic wrapper
// from the given value provided as v.
func NewUint8Element(v interface{}) *Uint8Element {
	return &Uint8Element{
		v: v,
	}
}

// compare takes the left and right elements and applies the comparator function to them.
func (e Uint8Element) compare(r Element, f func(left, right uint8) bool) (bool, error) {
	rE, ok := r.(*Uint8Element)
	if !ok {
		return false, fmt.Errorf("cannot cast %v to Uint8Element", r)
	}

	// When their nil status isn't the same, we can't compare them.
	// Explicit both nil should be handled elsewhere.
	if e.IsNil() != rE.IsNil() {
		return false, nil
	}

	lv, lok := e.v.(uint8)
	if !lok {
		return false, fmt.Errorf("cannot assert %v is a uint8", e.v)
	}
	rv, rok := rE.v.(uint8)
	if !rok {
		return false, fmt.Errorf("cannot assert %v is a uint8", rE.v)
	}

	return f(lv, rv), nil
}

// Comparation methods

// Eq returns true if the left Uint8Element is equal to the right Uint8Element.
// When both are nil Eq returns false because nil actualy signifies "unknown"
// and you can't compare two things when you don't know what they are.
func (e Uint8Element) Eq(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return false, nil
	}
	return e.compare(r, func(left, right uint8) bool {
		return left == right
	})
}

// EqStrict returns true if the left Uint8Element is equal to the right Uint8Element.
// When both are nil EqStrict returns true.
func (e Uint8Element) EqStrict(r Element) (bool, error) {
	if e.IsNil() && r.IsNil() {
		return true, nil
	}
	return e.compare(r, func(left, right uint8) bool {
		return left == right
	})
}

// Neq returns true if the left Uint8Element
// is not equal to the right Uint8Element.
func (e Uint8Element) Neq(r Element) (bool, error) {
	v, ok := e.Eq(r)
	return !v, ok
}

// Less returns true if the left Uint8Element
// is less than the right Uint8Element.
func (e Uint8Element) Less(r Element) (bool, error) {
	return false, errors.New("operator < not defined on Uint8")
}

// LessEq returns true if the left Uint8Element
// is less than or equal to the right Uint8Element.
func (e Uint8Element) LessEq(r Element) (bool, error) {
	return false, errors.New("operator <= not defined on Uint8")
}

// Greater returns true if the left Uint8Element
// is greter than the right Uint8Element.
func (e Uint8Element) Greater(r Element) (bool, error) {
	return false, errors.New("operator > not defined on Uint8")
}

// GreaterEq returns true if the left Uint8Element
// is greter than or equal to the right Uint8Element.
func (e Uint8Element) GreaterEq(r Element) (bool, error) {
	return false, errors.New("operator >= not defined on Uint8")
}

// Accessor/conversion methods

// Copy returns a copy of this Uint8Element.
func (e Uint8Element) Copy() Element {
	return e
}

// String prints the value of this element as a string.
func (e Uint8Element) String() string {
	return fmt.Sprintf("%v", e.v)
}

// Information methods

// IsNil returns true when the underlying value is nil.
func (e Uint8Element) IsNil() bool {
	return e.v == nil
}
